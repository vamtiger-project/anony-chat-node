class Handle {
    constructor(vamtiger) {
        // If the abstract class is defined,
        if (vamtiger) {
            // then reference it
            this.vamtiger = vamtiger;
            // and bind the context of the Handle interface.
            // Note: This will preserve the expected context, regardless of
            //       asynchronousity.
            this.vamtiger.bind(Handle, this);
        }

        // Reference the defined regular expressions.
        this.regex = this._regex;
    }

    /**
     * This serves as a container for all regular expressions.
     **/
    get _regex() {
        var regex = {
            // This will be used to validate a user's email based on the following
            // parameters:
            // 1 - It must begin with 1/more word characters,
            // 2 - followed by an '@' character,
            // 3 - then terminating with the domain name.
            // Example of a valid match:
            //     - email@domain.com
            //     - email@another.domain.com
            // Example of an invalid match:
            //    - email
            //     - email@domain
            //     - email@another.domain.
            // Note:
            //     - Regular expressions in Javascript do not support unicode,
            //       though it is planned for the future.
            //       - Consider using xregexp on npm?
            email: /^\w+@(\w+\.\w+)+$/,

            // This will be used to constrain a user password to no less than 8
            // characters, based on the following criteria:
            // 1 - 8 or more word or non-word characters (i.e. 8 or more of
            //     any character).
            // Example of a valid match:
            //     - testPassword (12 characters)
            //     - anotherPassword (15 characters)
            // Example of an invalid match:
            //     - pass (4 characters)
            //     - '' (0 characters)
            password: /^[\w\W]{8,}$/,

            /**
             * This will match the MongoDb duplicate key error code.
             * Example of a valid match:
             *     - 11000 or '11000' (exact match)
             * Example of an invalid match:
             *     - 2020
             **/
            duplicateKeyErrorCode: /^11000$/,

            /**
             * This will match the error message for a duplicate email, base on
             * whether the error message contains:
             *     1 - The duplicate key error code string,
             *     2 - followed by the 'email' field name.
             * Example of a valid match:
             *     - E11000 duplicate key error collection: test.user_registrations index: email_1 dup key: { : "test@email.com" }
             * Example of an invalid match:
             *     - E12000 duplicate key error collection: test.user_registrations index: pass_1 dup key: { : "test@email.com" }
             **/
            duplicateEmail: /E11000.+email/i
        }

        return regex;
    }

    httpRequest(request, response) {}

    socketConnection(socket) {
        socket.on("disconnect", () => this.socketDisconnection(socket));
        socket.on("register", (data) => this.socketRegistration(socket, data));
        socket.on("directMessage", (data) => this.directMessage(socket, data));
        socket.on("mapToEmail", (email) => this.mapToEmail(socket, email));
        socket.on("multiChat", (data) => this.multiChat(socket, data));
        socket.on("searchChats", (data) => this.searchChats(socket, data));
        socket.on("removeTestData", this.removeTestData);

        // Add each socket the referenced socket map, mapping it to an email of
        // null.
        this.vamtiger.sockets.set(socket, null);
    }

    socketDisconnection(socket) {
        this.vamtiger.sockets.delete(socket);
    }

    /**
     * socket callback will be used for user registration.
     **/
    socketRegistration(socket, data) {
        // If the email is valid,
        this.validEmail(data)
            // and the password is valid,
            .then(this.validPassword)
            // then register the user.
            .then(() => this.registerUser(socket, data))
            // Otherwise, do not allow the user to register.
            .catch(() => this.preventRegistration(socket, data));
    }

    registerUser(socket, data) {
        var saveData = {
            model: "UserRegistrationModel",
            data: {
                email: data.email,
                password: data.password,
                online: true,
                email_validation: false,
                registration_date: new Date()
            }
        };

        // Register the user,
        this.vamtiger.database.save(saveData)
            // then notify the user of successful registration.
            .then((savedObject) => socket.emit("registered", savedObject))
            // Otherwise, prevent user registration.
            .catch((error) => {
                // If there was a duplicate key error due to the User Email already
                // existing in the database,
                if (this.regex.duplicateKeyErrorCode.test(error.code) &&
                this.regex.duplicateEmail.test(error.message)
                ) {
                    socket.emit("duplicateEmail", {
                        error: error
                    })
                }
            });
    }

    /**
     * This will prevent User registration, due to an input error.
     * This assumes that the either the user:
     *     1 - did not specify an email
     *     2 - specified an invalid email
     **/
    preventRegistration(socket, data) {
        // If no email was specified,
        if (data.error.noEmail) {
            // inform the user that no email was specified.
            socket.emit("noEmail");
        // Or if the email was invalid,
        } else if (data.error.invalidEmail) {
            // inform the user that the email was invalid.
            socket.emit("invalidEmail");
        // Or if no password was specified,
        } else if (data.error.noPassword) {
            // inform the user that the email was invalid.
            socket.emit("noPassword");
        // Or if the password is too short,
        } else if (data.error.shortPassword) {
            // inform the user that the password is too short.
            socket.emit("shortPassword");
        }
    }

    multiChat(socket, data) {
        this.vamtiger.sockets.forEach((email, connectedSocket) => {
            if (socket != connectedSocket)
                connectedSocket.emit("multiChat", data);
        });
    }

    searchChats(socket, data) {
        Object.keys(data).forEach((property) => {
            // Convert the message to a regular expression for a wider chat
            // search.
            if (property === "message")
                data[property] = new RegExp(data[property], "i");
        });

        this.vamtiger.database.query(data)
            .then((result) => socket.emit("chatSearchResults", result))
            .catch((error) => socket.emit("chatSearchError", error));
    }

    mapToEmail(socket, email) {
        this.vamtiger.sockets.set(socket, email);
        socket.emit("emailMapped");
    }

    directMessage(socket, data) {
        var recipientRegex = new RegExp(data.recipientId),
            saveData;

        this.vamtiger.sockets.forEach((email, recipientSocket) => {
            if (email === data.recipient) {
                saveData = {
                    model: "DirectMessageModel",
                    data: {
                        sender: data.sender,
                        recipient: data.recipient,
                        message: data.message,
                        date: new Date()
                    }
                };

                this.vamtiger.database.save(saveData)
                    .then((savedObject) => recipientSocket.emit("directMessageRecieved", savedObject))
                    .catch((error) => {
                        console.error(error);

                        socket.emit("directMessageError", {
                            error: error
                        });
                    });
            }
        });
    }

    validEmail(data) {
        // Return a new promise.
        return new Promise((resolve, reject) => {
            // Otherwise, if no email was specified.
            if (!data.email) {
                data.error = {
                    noEmail: true
                }

                reject(data);
            // Or if the email has been specified, and is valid,
            } else if (data.email && this.regex.email.test(data.email)){
                // then resolve the promise.
                resolve(data);
            // Or if the email has been specified, but is invalid.
            } else if (data.email && !(this.regex.email.test(data.email))) {
                data.error = {
                    invalidEmail: true
                }

                reject(data);
            }
        });
    }

    validPassword(data) {
        // Return a new promise.
        return new Promise((resolve, reject) => {
            // If no password was specified,
            if (!data.password) {
                data.error = {
                    noPassword: true
                };

                // reject the promise.
                reject(data);
            // Or if the password has been specified, and is valid,
            } else if (data.password && this.regex.password.test(data.password)) {
                // then resolve the promise.
                resolve(data);
            // Or if the password has been specified, but is invalid.
            } else if (data.password && !(this.regex.password.test(data.password))) {
                data.error = {
                    shortPassword: true
                };

                // then reject the promise.
                reject(data);
            }
        });
    }

    removeTestData() {
        var removeTestUsersQuery = {
            "email": /test_\d+_@email.com/
        }

        this.vamtiger.database.remove(removeTestUsersQuery);
    }
}

module.exports = Handle;
